# Chapter 12: An I/O Project: Building a Command Line Program
This chapter is a recap of the many skills you have learned so far an exploration of a few more standard library features. We will build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.

Rust's speed, safety, single binary output, and cross-platform support make it an ideal language for creating command line tools, so for our project, we will make our own version of the classic command line tool `grep` (globally search a regular expression and print). In the simplest use case, `grep` searches a specified file for a specified string. To do so, `grep` takes as its arguments a filename and a string. Then it reads the file, finds line in that file that contain the string argument, and prints those lines.

Along the way, we will show how to make our command line tool use features of the terminal that many command line tools use. We will read the values of an environment variable to allow the user to configure the behavior of our tool. We will also print error messages to the standard error console stream (`stderr`) instead of standard output (`stdout`), so for example, the user can redirect successful output to a file while still seeing error message on screen.

One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of `grep`, called `ripgrep`. By comparison, our version of `grep` will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as `ripgrep`.

Our `grep` project will combine a number of concepts you have learned so far:

+ Organizing code, chapter 7
+ Using vectors and string, chapter 8
+ Handling error, chapter 9
+ Using traits and lifetimes where appropriate, chapter 10
+ Writing tests, chapter 11

We will also briefly introduce closures, iterators, and trait objects, which chapters 13 and 17 will cover in detail.

## Index
1. Accepting Command Line Arguments
2. Reading a File
3. Refactoring to Improve Modularity and Error Handling
4. Developing the Library's Functionality with Test Drive Development
5. Working with environment variables
6. Writing Error Messages

## 1. Accepting Command Line Arguments
Let's create a new project with, as always, `cargo new`. We will call our project `mingrep` to distinguish it from the `grep` tool that you might already have on your system.

```
$ cargo new minigrep
    Created binary (application) `minigrep` project
$ cd minigrep
```
The first task is to make `minigrep` accept its two command line arguments: The filename and a string to search for. That is, we want to be able to run our program with `cargo run`, a string to search for, and a path to a file to search in, like so:

```
$ cargo run searchstring example-filename.txt
```

Right now, the program generated by `cargo new` cannot process arguments we give it. Some existing libraries on crates.io can help with writing a program that accepts command line arguments, but because you are just learning this concept, let's implement this capability ourselves.

### Reading the Argument Values
To enable `minigrep` to read the values of command line arguments we pass to it, we will need a function provided in Rust's standard library, which is `std::env::args`. This function returns an iterator of the command line arguments that were given to `minigrep`. We will cover iterators fully in chapter 13. For now, you only need to know two details about iterators:

1. Iterators produces a series of values
2. We can call the `collect` method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.

Use the code below to allow your `minigrep` program to read any command line arguments passed to it and then collect the values in a vector:

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```

First, we bring the `std::env` module into scope with a use statement so we can use its `args` function. Notice that the `std::env::args` function is nested in two levels of modules. As we discussed in Chapter 7, in cases where the desired function is nested in more than one module, it’s conventional to bring the parent module into scope rather than the function. By doing so, we can easily use other functions from `std::env`. It’s also less ambiguous than adding use `std::env::args` and then calling the function with just `args`, because `args` might easily be mistaken for a function that’s defined in the current module.

> ### The `args` Function and Invalid Unicode
> Note that `std::env::args` will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use `std::env::args_os` instead. That function returns an iterator that produces `OsString` values instead of String values. We’ve chosen to use `std::env::args` here for simplicity, because `OsString` values differ per platform and are more complex to work with than String values.

On the first line of `main`, we call `env::args`, and we immediately use collect to turn the iterator into a vector containing all the values produced by the iterator. We can use the collect function to create many kinds of collections, so we explicitly annotate the type of `args` to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, collect is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want.

Finally, we print the vector using the debug formatter, `:?`. Let’s try running the code first with no arguments and then with two arguments:

```
$ cargo run
--snip--
["target/debug/minigrep"]

$ cargo run needle haystack
--snip--
["target/debug/minigrep", "needle", "haystack"]
```

Notice that the first value in the vector is `"target/debug/minigrep"`, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It’s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we’ll ignore it and save only the two arguments we need.

### Saving the Argument Values in Variables
Printing the value of the vector of arguments illustrated that the program is able to access the values specified as command line arguments. Now we need to save the values of the two arguments in variables so we can use the values throughout the rest of the program.

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
```

As we saw when we printed the vector, the program’s name takes up the first value in the vector at `args[0]`, so we’re starting at index `1`. The first argument `minigrep` takes is the string we’re searching for, so we put a reference to the first argument in the variable `query`. The second argument will be the `filename`, so we put a reference to the second argument in the variable `filename`.

We temporarily print the values of these variables to prove that the code is working as we intend. Let’s run this program again with the arguments `test` and `sample.txt`:

```
$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
       Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
            Rndling Errors Returned from run in mainunning `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```
Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we’ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we’ll ignore that situation and work on adding file-reading capabilities instead.j

## 2. Reading a File
Now we’ll add functionality to read the file that is specified in the `filename`  command line argument. First, we need a sample file to test it with: the best kind of file to use to make sure `minigrep` is working is one with a small amount of text over multiple lines with some repeated words. For this case we will use the _poem.txt_ with the next content:

```
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```

Now, to read the file, we should edit the _src/main.rs_ file with the next code:

```rust
use std::env;
use std::fs;

fn main() {
    // --snip--
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents)
}
```

First, we add another use statement to bring in a relevant part of the standard library: we need `std::fs` to handle files.

In main, we’ve added a new statement: `fs::read_to_string` takes the filename, opens that file, and returns a `Result<String>` of the file’s contents.

After that statement, we have again added a temporary `println!` statement that prints the value of contents after the file is read, so we can check that the program is working so far.

Let’s run this code with any string as the first command line argument (because we haven’t implemented the searching part yet) and the _poem.txt_ file as the second argument:

```
$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
       Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
            Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us — don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```

Great! The code read and then printed the contents of the file. But the code has a few flaws. The `main` function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we’re not handling errors as well as we could. The program is still small, so these flaws aren’t a big problem, but as the program grows, it will be harder to fix them cleanly. It’s good practice to begin refactoring early on when developing a program, because it’s much easier to refactor smaller amounts of code. We’ll do that next.

## 3. Refactoring to Improve Modularity and Error Handling
To improve our program, we will fix four problems that have to do with the program's structure and how it is handling potential errors.

First, our `main` function now performs two tasks: it parses arguments and reads files. For such a small function, this isn’t a major problem. However, if we continue to grow our program inside `main`, the number of separate tasks the main function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It’s best to separate functionality so each function is responsible for one task.

This issue also ties into the second problem: although query and filename are configuration variables to our program, variables like contents are used to perform the program’s logic. The longer main becomes, the more variables we’ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It’s best to group the configuration variables into one structure to make their purpose clear.

The third problem is that we’ve used expect to print an error message when reading the file fails, but the error message just prints `Something went wrong reading the file`. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we’d print the `Something went wrong reading the file` error message, which wouldn’t give the user any information!

Fourth, we use `expect` repeatedly to handle different errors, and if the user runs our program without specifying enough arguments, they’ll get an index out of bounds error from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult in the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we’re printing messages that will be meaningful to our end users.

Let's address these four problems by refactoring our projects

### Separation of Concerns for Binary Projects
The organizational problem of allocating responsibility for multiple tasks to the `main` function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when `main` starts getting large. The process has the following steps:

1. Split your program into a `main.rs` and a `lib.rs` and move your program's logic to `lib.rs`
2. As long as your command line parsing logic is small, it can remain in `main.rs`
3. When the command line parsing logic starts getting complicated, extract it form `main.rs` and move it to `lib.rs`

The responsibilities that remain in the `main` function after this process should be limited to the following:

- Calling the command line parsing logic with the argument values
- Setting up any other configuration
- Calling a run function in lib.rs
- Handling the error if run returns an error

This pattern is about _separating concerns_: `main.rs` handles running the program, and lib.rs handles all the logic of the task at hand. Because you can’t test the `main` function directly, this structure lets you test all of your program’s logic by moving it into functions in `lib.rs`. The only code that remains in main.rs will be small enough to verify its correctness by reading it. Let’s rework our program by following this process.

#### Extracting the Argument Parser
We’ll extract the functionality for parsing arguments into a function that `main` will call to prepare for moving the command line parsing logic to `src/lib.rs`. Next snippet shows the new start of `main` that calls a new function `parse_config,` which we’ll define in `src/main.r`s for the moment.

```rs
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    println!("Searching for {}", query);
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents)
}

fn parse_config(args: &[String]) -> (&str, &str) -> {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
```
We’re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable `query` and the argument value at index 2 to the variable `filename` within the `main` function, we pass the whole vector to the `parse_config` function. The `parse_config` function then holds the logic that determines which argument goes in which variable and passes the values back to `main`. We still create the `query` and `filename` variables in `main`, but `main` no longer has the responsibility of determining how the command line arguments and variables correspond.

This rework may seem like overkill for our small program, but we’re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It’s good to check your progress often, to help identify the cause of problems when they occur.

#### Grouping Configuration Values
We can take another small step to improve the `parse_config` function further. At the moment, we’re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don’t have the right abstraction yet.

Another indicator that shows there’s room for improvement is the `config` part of `parse_config`, which implies that the two values we return are related and are both part of one configuration value. We’re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.

> Note: Using primitive when a complex type would be more appropriate is an anti-pattern knows as _primitive obsession_.

Next code shows the improvements to the `parse_config` function:

```rs
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents)
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config -> {
    let query = &args[1].clone;
    let filename = &args[2].clone;

   Config { query, filename }
}
```

We’ve added a struct named `Config` defined to have fields named `query` and `filename`. The signature of `parse_config` now indicates that it returns a `Config` value. In the body of `parse_config`, where we used to return string slices that reference `String` values in `args`, we now define `Config` to contain owned `String` values. The `args` variable in `main` is the owner of the argument values and is only letting the `parse_config` function borrow them, which means we’d violate Rust’s borrowing rules if `Config` tried to take ownership of the values in `args`.

We could manage the `String` data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the clone method on the values. This will make a full copy of the data for the `Config` instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don’t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.

> ### The Trade-Offs of Using `clone`
> There is a tendency among many Rustaceans to avoid using `clone` to fix ownership problems because of its runtime cost. For now, it is okay to copy few string to continue making progress because you will make these copies only once and your filename and query string are very small. It is better to have a working program that is bit inefficient that to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it will be easier to start with the most efficient solution, but for now, it is perfectly acceptable to call `clone`.

We’ve updated `main` so it places the instance of `Config` returned by `parse_config` into a variable named `config`, and we updated the code that previously used the separate `query` and `filename` variables so it now uses the fields on the `Config` struct instead.

Now our code more clearly conveys that `query` and `filename` are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the `config` instance in the fields named for their purpose.

#### Creating a Constructor for Config
So far, we’ve extracted the logic responsible for parsing the command line arguments from `main` and placed it in the `parse_config` function. Doing so helped us to see that the `query` and `filename` values were related and that relationship should be conveyed in our code. We then added a `Config` struct to name the related purpose of `query` and `filename` and to be able to return the values’ names as struct field names from the `parse_config` function.

So now that the purpose of the parse_config function is to create a `Config` instance, we can change `parse_config` from a plain function to a function named new that is associated with the `Config` struct. Making this change will make the code **more idiomatic**. We can create instances of types in the standard library, such as `String`, by calling `String::new`. Similarly, by changing `parse_config` into a new function associated with `Config`, we’ll be able to create instances of `Config` by calling `Config::new`. 

```rs
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents)
}

struct Config {
    query: String,
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Config -> {
        let query = &args[1].clone;
        let filename = &args[2].clone;

        Config { query, filename }
    }
}
```
We’ve updated main where we were calling `parse_config` to instead call `Config::new`. We’ve changed the name of `parse_config` to new and moved it within an `impl`  block, which associates the new function with `Config`. Try compiling this code again to make sure it works.

### Fixing the Error Handling

#### Improving the Error Message
#### Returning a Result from new
#### Calling Config::new and Handling Errors

### Extracting Logic from main

#### Returning Errors from the run Function
#### Handling Errors Returned from run in main

### Splitting Code into a Library Crate
 
## 4. Developing the Library's Functionality with Test Drive Development
## 5. Working with environment variables
## 6. Writing Error Messages
