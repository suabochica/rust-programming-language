# Chapter 12: An I/O Project: Building a Command Line Program
This chapter is a recap of the many skills you have learned so far an exploration of a few more standard library features. We will build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.

Rust's speed, safety, single binary output, and cross-platform support make it an ideal language for creating command line tools, so for our project, we will make our own version of the classic command line tool `grep` (globally search a regular expression and print). In the simplest use case, `grep` searches a specified file for a specified string. To do so, `grep` takes as its arguments a filename and a string. Then it reads the file, finds line in that file that contain the string argument, and prints those lines.

Along the way, we will show how to make our command line tool use features of the terminal that many command line tools use. We will read the values of an environment variable to allow the user to configure the behavior of our tool. We will also print error messages to the standard error console stream (`stderr`) instead of standard output (`stdout`), so for example, the user can redirect successful output to a file while still seeing error message on screen.

One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of `grep`, called `ripgrep`. By comparison, our version of `grep` will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as `ripgrep`.

Our `grep` project will combine a number of concepts you have learned so far:

+ Organizing code, chapter 7
+ Using vectors and string, chapter 8
+ Handling error, chapter 9
+ Using traits and lifetimes where appropriate, chapter 10
+ Writing tests, chapter 11

We will also briefly introduce closures, iterators, and trait objects, which chapters 13 and 17 will cover in detail.

## Index
1. Accepting Command Line Arguments
2. Reading a File
3. Refactoring to Improve Modularity and Error Handling
4. Developing the Library's Functionality with Test Drive Development
5. Working with environment variables
6. Writing Error Messages

## 1. Accepting Command Line Arguments
Let's create a new project with, as always, `cargo new`. We will call our project `mingrep` to distinguish it from the `grep` tool that you might already have on your system.

```
$ cargo new minigrep
    Created binary (application) `minigrep` project
$ cd minigrep
```
The first task is to make `minigrep` accept its two command line arguments: The filename and a string to search for. That is, we want to be able to run our program with `cargo run`, a string to search for, and a path to a file to search in, like so:

```
$ cargo run searchstring example-filename.txt
```

Right now, the program generated by `cargo new` cannot process arguments we give it. Some existing libraries on crates.io can help with writing a program that accepts command line arguments, but because you are just learning this concept, let's implement this capability ourselves.

### Reading the Argument Values
To enable `minigrep` to read the values of command line arguments we pass to it, we will need a function provided in Rust's standard library, which is `std::env::args`. This function returns an iterator of the command line arguments that were given to `minigrep`. We will cover iterators fully in chapter 13. For now, you only need to know two details about iterators:

1. Iterators produces a series of values
2. We can call the `collect` method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.

Use the code below to allow your `minigrep` program to read any command line arguments passed to it and then collect the values in a vector:

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```

First, we bring the `std::env` module into scope with a use statement so we can use its `args` function. Notice that the `std::env::args` function is nested in two levels of modules. As we discussed in Chapter 7, in cases where the desired function is nested in more than one module, it’s conventional to bring the parent module into scope rather than the function. By doing so, we can easily use other functions from `std::env`. It’s also less ambiguous than adding use `std::env::args` and then calling the function with just `args`, because `args` might easily be mistaken for a function that’s defined in the current module.

> ### The `args` Function and Invalid Unicode
> Note that `std::env::args` will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use `std::env::args_os` instead. That function returns an iterator that produces `OsString` values instead of String values. We’ve chosen to use `std::env::args` here for simplicity, because `OsString` values differ per platform and are more complex to work with than String values.

On the first line of `main`, we call `env::args`, and we immediately use collect to turn the iterator into a vector containing all the values produced by the iterator. We can use the collect function to create many kinds of collections, so we explicitly annotate the type of `args` to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, collect is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want.

Finally, we print the vector using the debug formatter, `:?`. Let’s try running the code first with no arguments and then with two arguments:

```
$ cargo run
--snip--
["target/debug/minigrep"]

$ cargo run needle haystack
--snip--
["target/debug/minigrep", "needle", "haystack"]
```

Notice that the first value in the vector is `"target/debug/minigrep"`, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It’s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we’ll ignore it and save only the two arguments we need.

### Saving the Argument Values in Variables
Printing the value of the vector of arguments illustrated that the program is able to access the values specified as command line arguments. Now we need to save the values of the two arguments in variables so we can use the values throughout the rest of the program.

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
```

As we saw when we printed the vector, the program’s name takes up the first value in the vector at `args[0]`, so we’re starting at index `1`. The first argument `minigrep` takes is the string we’re searching for, so we put a reference to the first argument in the variable `query`. The second argument will be the `filename`, so we put a reference to the second argument in the variable `filename`.

We temporarily print the values of these variables to prove that the code is working as we intend. Let’s run this program again with the arguments `test` and `sample.txt`:

```
$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
       Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
            Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```
Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we’ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we’ll ignore that situation and work on adding file-reading capabilities instead.j



## 2. Reading a File
## 3. Refactoring to Improve Modularity and Error Handling
## 4. Developing the Library's Functionality with Test Drive Development
## 5. Working with environment variables
## 6. Writing Error Messages
